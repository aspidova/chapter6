# 6.7.2 Шутки про тук-тук.

Наш следующий раздел про шутки по просьбе моего семилетнего внука Уильяма, который просто обожает шутки про тук-тук.

Как вы, наверное, знаете, шутка про тук-тук - это шутка, основанная на каламбуре, который всегда принимает одну и ту же форму.

* _\(person 1\) Knock, knock_
* _\(person 2\) Who’s there?_
* _\(person 1\) Wooden_
* _\(person 2\) Wooden Who?_
* _\(person 1\) Wooden you like to know!_

Так что диалог очень простой. Мы можем определить общую структуру шутки в следующем виде:

1.  _Knock, knock._
2. _Who’s there?_
3. _&lt;word 1&gt;_
4.  _&lt;word 1&gt; who?_
5.  _&lt;punchline phrase&gt;_

Определяя шутку, можно увидеть, что у нас всего лишь два изменяющихся элемента - слово на шаге 3 и 4, и фраза на шаге 5. Начнем создание базы шуток с однострочных анекдотов, которые положим в текстовый файл. Поскольку имеется только два элемента, можно разделить их косой чертой/:

```text
tarzan / tarzan stripes forever
orange / orange you glad I can tell jokes?
```

И так далее. Я предоставляю вам базу из 10 шуток, которые в можете найти в файлах репозитория для этой главы. Не стесняйтесь добавлять свои любимые шутки и отправлять мне, я добавлю их.

В  первом разделе мы рассмотрим случай, когда робот начинает шутку. Это навык, как и любой другой, вызывается словами "Хэй, Альберт." Тогда нужна фраза, указывающая на то, что мы хотим услышать шутку, поэтому будет использоваться два варианта _Tell me a knock-knock joke_, _I want to hear a knock-knock joke._

Это вызовет нашу программу поиска шутки. Мы создадим несколько вариантов ответа пользователю. Начнем с ответа на вопрос  “Кто там?”. Ответ пользователя даст роботу знак, о том, что надо перейти к следующей части шутки, в которой присутствует наше слово. Для этого отключим диалог "Кто там" и включим диалог для прослушивания фразы "кто" и нужного слова. Тогда мы сможем произнести кульминационную часть шутки.

Начнем с создания словарных файлов, которых понадобится целых три штуки. Это те фразы, которые пользователь будет говорить роботу. У нас есть первая шутливая фраза ****_tell me a knock, knock joke_ - так что давайте назовем файл `knockknock.voc` и вставим в него следующее:

```text
Tell me a knock-knock joke
Can I have a knock-knock joke
Give me a knock-knock joke
Play me a knock-knock joke
```

Обратите внимание на то, что система “Речь в текст” должна интерпретировать фразу _knock, knock_ как _knock-knock_ с дефисом, это важно внести в сценарий. 

Этого должно быть достаточно для достижения поставленных целей. Теперь необходимо создать второй .voc файл, `whosthere.voc` , который будет содержать одну строку:

```text
Whos there
```

Создайте третий файл под названием `who.voc` и поместите в него одно слово. Помните, что все они находятся в папке **dialog/en-us** в каталоге навыков. Теперь поработаем над ответами. У нас есть один стандартный ответ, который должен прозвучать, чтобы начать шутку “_tell me a knock-knock joke_”. Нет необходимости в каких-то сложных диалоговых системах.

Далее импортируем библиотеки, которые нужны для написания программы - это класс `MycroftSkill` и функция `intent_file_handler`:

```text
from mycroft import MycroftSkill, intent_file_handler
```

Наш навык определяется как дочерний объект. Он наследует все функции и данные родительского MycroftSkill и добавляет к нему свой собственный функционал \(Что свойственно объектно-ориентированному программированию\). Далее создается функция инициализации, а затем пишется вызов `init` для выполнения кода класса-родителя. Необходимо расширить функционал родительской функции `init`. Без этого пришлось бы заменить функцию `init` на собственную, и, возможно, проделать значительный объем работы:

```text
class Knockknock(MycroftSkill):
def __init__(self):
MycroftSkill.__init__(self)
```

Следующий шаг - создание обработчика намерений. Обработчик намерений вызывается, когда движок находит ключевые слова, указывающие на то, что нам нужно. Всякий раз, когда пользователь спросит “_Do you know any knock-knock jokes?_” или произнесет другие фразы с похожим смыслом, этот код будет вызываться. Фразы помещаются в файл `knockknock.intent`, а затем файл сохраняется в каталог voc:

```text
@intent_file_handler('knockknock.intent')
def handle_knockknock(self, message):
```

Теперь нужно выбрать шутку из базы данных. Ниже в программе мы определяем функцию `pick_joke` и получаем две составляющие шутки: имя, которое можно назвать, и кульминационный момент, который заканчивает шутку:

```text
name,punchline = self.pick_joke()
```

Далее используется функция `get_response`, чтобы робот ждал ответа, который будет превращен в текстовую строку и сохранен в переменной:

```text
response=self.get_response(announcement="knock, knock")
# response will always be "who's there"
response=self.get_response(announcement=name)
```

Теперь мы находимся на той части, где робот произносит имя, после ответа на вопрос «_Кто там?_». Например, пользователь говорит «_Кто там?_», а робот отвечает _"Гарольд"_. Что мы ждем дальше, так это чтобы пользователь ответил «_Какой Гарольд \(или как его там\)?_». Затем робот проверяет включено ли в ответ слово "_кто_". Если оно отсутствует, можно подсказать пользователю ответ. Мы делаем это только один раз, чтобы не застрять в петле. Если пользователь не подыгрывает, робот просто продолжит:

```text
response will be "name who"
# if end of respose is not the word who, we can re-prompt
if "who" not in response:
prompt = "You are supposed to say "+name+" who"
response=self.get_response(announcement=prompt)
```

Теперь можно перейти к главной фишке - шутке, например «_Гарольд, тебе нравятся объятия?_» \(Как насчет объятий?\):

```text
self.speak(punchline)
```

Нам нужна функция для чтения базы данных шуток, которую мы определили ранее. В базе данных есть шутка по одной на каждую строку, с передней косой чертой \(/\) между именем и кульминационной линией. Мы читаем все анекдоты, копируем их в список, а затем случайным образом выбираем один из них с помощью функции `random.choice`. Программа возвращает имя и кульминационный момент отдельно:

```text
def pick_joke():
jokeFile="knockknock.jokes"
jfile = open(jokeFile,"r")
jokes = []
for jokeline in jfile:
jokes.append(jokeline)
joke = choice(jokes)
jokeParts = joke.split("/")
name = jokeParts[0]
punchline = jokeParts[1]
return name, punchline
```

Завершаем программу определением экземпляра класса `Knockknock` и возвращаем этот объект вызывающей программе Mycroft:

```text
def create_skill():
return Knockknock()
```



